#version 450


layout (local_size_x = 256) in;

layout (set = 0, binding = 5) uniform CameraBuffer {
	mat4 view;
	mat4 proj;
	mat4 viewproj;
} cameraData;

struct DrawCullData {
	mat4 view;
	float P00, P11, znear, zfar; // symmetric projection parameters
	float frustum[4]; // data for left/right/top/bottom frustum planes
	float lodBase, lodStep; // lod distance i = base * pow(step, i)
	float pyramidWidth, pyramidHeight; // depth pyramid size in texels

	uint drawCount;

	int cullingEnabled;
	int frustumCullingEnabled;
	int occlusionEnabled;
	int AABBcheck;
	float aabbmin_x;
	float aabbmin_y;
	float aabbmin_z;
	float aabbmax_x;
	float aabbmax_y;
	float aabbmax_z;
};

layout (push_constant) uniform constants {
    DrawCullData cullData;
};

layout (set = 0, binding = 4) uniform sampler2D depthPyramid;

struct ObjectData {
	mat4 model;
	vec4 spherebounds;
	vec4 extents;
};

// all object matrices
layout (std140,set = 0, binding = 0) readonly buffer ObjectBuffer {
	ObjectData objects[];
} objectBuffer;

struct DrawCommand {
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	int  vertexOffset;
	uint firstInstance;
	uint objectID;
	uint batchID;
};

// draw indirect buffer
layout (set = 0, binding = 1) buffer InstanceBuffer {
	DrawCommand Draws[];
} drawBuffer;

struct GPUInstance {
	uint objectID;
	uint batchID;
};

// draw indirect buffer
layout (set = 0, binding = 2) readonly buffer InstanceBuffer2 {
	GPUInstance Instances[];
} compactInstanceBuffer;

// draw indirect buffer
layout (set = 0, binding = 3) buffer InstanceBuffer3 {
	uint IDs[];
} finalInstanceBuffer;


float linearizeDepth(float depth) {
    float z = depth * 2.0 - 1.0; // back to NDC
    return (2.0 * cullData.znear * cullData.zfar) / (cullData.zfar + cullData.znear - z * (cullData.zfar - cullData.znear));
}

// depthSample from depthTexture.r, for instance
float linearDepth(float depthSample) {
    depthSample = 2.0 * depthSample - 1.0;
    float zLinear = 2.0 * cullData.znear * cullData.zfar / (cullData.zfar + cullData.znear - depthSample * (cullData.zfar - cullData.znear));
    return zLinear;
}

// result suitable for assigning to gl_FragDepth
float depthSample(float linearDepth) {
    float nonLinearDepth = (cullData.zfar + cullData.znear - 2.0 * cullData.znear * cullData.zfar / linearDepth) / (cullData.zfar - cullData.znear);
    nonLinearDepth = (nonLinearDepth + 1.0) / 2.0;
    return nonLinearDepth;
}

// 2D Polyhedral Bounds of a Clipped, Perspective-Projected 3D Sphere. Michael Mara, Morgan McGuire. 2013
bool projectSphere(vec3 C, float r, float znear, float P00, float P11, out vec4 aabb) {
	// if we intersect the near plane consider it visible
	if (C.z + r < znear) //if (C.z < r + znear) // TODO: this culls objects that intersect znear like the terrain
		return false;

	vec2 cx = -C.xz;
	vec2 vx = vec2(sqrt(dot(cx, cx) - r * r), r);
	vec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * cx;
	vec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * cx;

	vec2 cy = -C.yz;
	vec2 vy = vec2(sqrt(dot(cy, cy) - r * r), r);
	vec2 miny = mat2(vy.x, vy.y, -vy.y, vy.x) * cy;
	vec2 maxy = mat2(vy.x, -vy.y, vy.y, vy.x) * cy;
	aabb = vec4(minx.x / minx.y * P00, miny.x / miny.y * P11, maxx.x / maxx.y * P00, maxy.x / maxy.y * P11);
	aabb = aabb.xwzy * vec4(0.5f, -0.5f, 0.5f, -0.5f) + vec4(0.5f); // clip space -> uv space

	return true;
}

bool IsVisible(uint objectIndex) {
	uint index = objectIndex;

	vec4 sphereBounds = objectBuffer.objects[index].spherebounds;

	vec3 center = sphereBounds.xyz;
	center = (cullData.view * vec4(center, 1.f)).xyz;
	float radius = sphereBounds.w;

	bool visible = true;

	// the left/top/right/bottom plane culling utilizes frustum symmetry to cull against two planes at the same time
	visible = center.z * cullData.frustum[1] - abs(center.x) * cullData.frustum[0] > -radius;
	visible = visible && center.z * cullData.frustum[3] - abs(center.y) * cullData.frustum[2] > -radius;

	// TODO: fix this. why does z end up being negative after view transformation
	center.z *= -1;
	if (visible) {
		// the near/far plane culling uses camera space Z directly
		visible = center.z + radius > cullData.znear && center.z - radius < cullData.zfar;
	}


	visible = visible || cullData.frustumCullingEnabled == 0;

	// flip Y because we access depth texture that way
	center.y *= -1; // TODO: really?

	if (visible && cullData.occlusionEnabled != 0) {
		vec4 aabb;
		if (projectSphere(center, radius, cullData.znear, cullData.P00, cullData.P11, aabb)) {
			float width = (aabb.z - aabb.x) * cullData.pyramidWidth;
			float height = (aabb.y - aabb.w) * cullData.pyramidHeight;

			// TODO: ceil results in less flicker but doesnt seem to cull as much as floor
			float level = floor(log2(max(width, height)));

			// we dont have access to filter minmax on macos so we cant use this technique
			// Sampler is set up to do min reduction, so this computes the minimum depth of a 2x2 texel quad
			// float depth = textureLod(depthPyramid, (aabb.xy + aabb.zw) * 0.5, level).x;

			float d1 = textureLod(depthPyramid, aabb.xy, level).x;
			float d2 = textureLod(depthPyramid, aabb.zy, level).x;
			float d3 = textureLod(depthPyramid, aabb.xw, level).x;
			float d4 = textureLod(depthPyramid, aabb.zw, level).x;
			float depth = max(max(d1, d2), max(d3, d4)); // TODO: should this be a min?
			float depthMin = min(min(d1, d2), min(d3, d4));

			float depthSphere = cullData.znear / (center.z - radius);
			visible = visible && depthSphere >= 1.0 - depth;

			// linearize the depth value. attempt to get depth into camera space
			float n = cullData.znear;
			float f = cullData.zfar;
			float z = (2 * n * f) / (f + n - depth * (f - n));
			float z2 = (n * f) / (f - depth * (f - n));

			float otherZ = linearizeDepth(depth);

			float depthToCamera = linearDepth(depth);

			// ??? center - radius is closest point in z-dir. If that is closer then depth we are visible. Probably the maxes above should be mins for that?
			float glFragDepth = depthSample(center.z - radius);

			// TODO: fix all this shit
			// visible = visible && depthSphere >= 1.0 - depth;
			// visible = visible && z >= depthSphere;
			// visible = visible && otherZ <= z || depthSphere >= 1.0 - depth;
			// visible = visible && glFragDepth < depth;

			// float sphereCenterToClip = glFragDepth;
			float clipDepthToCamera = linearDepth(depthMin);

			float clipFragMin = depthSample(center.z - radius);
			float clipFragMax = depthSample(center.z + radius);
			bool passes1 = clipFragMin < depthMin;

			bool passes2 = (center.z - radius) < clipDepthToCamera;
			bool passes3 = depthSphere >= 1.0 - depth;
			// visible = visible && depthSphere >= 1.0 - depth;

			// float throwaway = clipFragMax - clipFragMin;
		}
	}

	return visible;
}

bool IsVisibleAABB(uint objectIndex) {
	vec4 sphereBounds = objectBuffer.objects[objectIndex].spherebounds;

	vec3 center = sphereBounds.xyz;
	// center = (cullData.view * vec4(center, 1.f)).xyz; // we DONT translate into the ortho camera space since we have world AABB of it
	float radius = sphereBounds.w;

	bool visible = true;

	vec3 aabbmin = vec3(cullData.aabbmin_x, cullData.aabbmin_y, cullData.aabbmin_z) - vec3(radius);
	vec3 aabbmax = vec3(cullData.aabbmax_x, cullData.aabbmax_y, cullData.aabbmax_z) + vec3(radius);

	visible = visible && (center.x > aabbmin.x) && (center.x < aabbmax.x);
	visible = visible && (center.y > aabbmin.y) && (center.y < aabbmax.y);
	visible = visible && (center.z > aabbmin.z) && (center.z < aabbmax.z);

	return visible;
}

void main() {
	uint gID = gl_GlobalInvocationID.x;
	if (gID < cullData.drawCount) {
		uint objectID = compactInstanceBuffer.Instances[gID].objectID;

		bool visible = false;

		// allows fully disabling culling
		if (cullData.cullingEnabled == 1) {
			if (cullData.AABBcheck == 1)
				visible = IsVisibleAABB(objectID);
			else
				visible = IsVisible(objectID);
		} else {
			visible = true;
		}

		if (visible) {
			uint batchIndex = compactInstanceBuffer.Instances[gID].batchID;
			uint countIndex = atomicAdd(drawBuffer.Draws[batchIndex].instanceCount, 1);

			uint instanceIndex = drawBuffer.Draws[batchIndex].firstInstance + countIndex;
			finalInstanceBuffer.IDs[instanceIndex] = objectID;
		}
	}
}
